(rem s 2)
(rem 0 2)
(rem 1 2)
(rem 2 2)
(Integer. "5")
[h m s] (map #(Integer. %) (split "10:05:48" ":"))
(map #(Integer. %) (split "10:05:48" ":"))
(use '[clojure.string :only (join split)])
(map #(Integer. %) (split "10:05:48" ":"))
(Integer. "10")
(split "10:05:48" ":")
(split "10:05:48" #":")
(map #(Integer. %) (split "10:05:48" #":"))
(div 20 5)
(/ 20 5)
(quot 20 5)
(quot 21 5)
(quot 0 5)
(quot 4 5)
(quot 5 5)
(quot 6 5)
(quot 7 5)
(quot 8 5)
(quot 9 5)
(quot 10 5)
(quot 11 5)
(repeat "R" (quot 11 5)) 
(repeat (quot 11 5) "R") 
(repeat (- 4 (quot 11 5)) "O") 
(concat (repeat (quot 11 5) "R")(repeat (- 4 (quot 11 5)) "O") )
(apply str (concat (repeat (quot 11 5) "R")(repeat (- 4 (quot 11 5)) "O") ))
(rem 11 5)
(rem 12 5)
(rem 21 5)
(cycle "R" "R" "Y")
(cycle ["R" "R" "Y"])
(take 1 (cycle ["R" "R" "Y"]))
(take 2 (cycle ["R" "R" "Y"]))
(take 3 (cycle ["R" "R" "Y"]))
(take 4 (cycle ["R" "R" "Y"]))
(take 5 (cycle ["R" "R" "Y"]))
(take 11 (cycle ["R" "R" "Y"]))
(load-file "./src/berlin_clock/core.clj")
(berlin_clock.core/show "16:50:00")
(partial apply str concat)
(def f (partial apply str concat))
(f [1 2] [3 4])
(f ["1" "2"] ["3" "4"])
(partial (apply str concat))
(partial (apply str (concat)))
(def f (partial (apply str) concat))
(def f (partial apply str concat))
(partial apply str)
(def f (partial apply str))
(f (concat [1 2] [3 4])
)
(def g (partial f concat))
(g [1 2] [3 4])
(def g (comp f concat))
(g [1 2] [3 4])
(def show (comp (partial apply str) concat))
(show [1 2] [3 4])
